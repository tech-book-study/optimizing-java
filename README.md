# 1장 성능과 최적화

일반적인 원칙

- JVM을 더 빨리 작동시키는 마법의 스위치는 없다.
- 자바를 더 빨리 실행하게 만드는 '팁, 트릭'은 없다.
- 비밀 알고리즘도 없다.

## 자바 성능 개요

자바 성능의 본질 by 제임스 고슬링

> 자바는 블루 칼라(주로 생산직에 종사하는 육체 노동자) 언어입니다. 박사 학위 논문 주제가 아니라 일을 하기 위해 만든 언어입니다.

자바는 실용성을 추구하기 때문에 개발자가 일일이 용량을 세세하게 관리하는 부담을 덜어주고 저수준으로 제어 가능한 일부 기능을 포기하는 발상이다. 이것이 서브시스템이다. 예를들어 메모리관리가 있다. 

## 성능분류

- 처리율

처리율은 시스템이 수행 가능한 작업 비율을 나타낸 지표이다. 보통 일정 시간 동안 완료한 작업 단위 수. 예를들어 초당 처리가능한 트랜잭션 수.

- 지연

1초에 100리터를 흘려보내는 수도관의 처리율은 바로 1초에 처리되는 부피 즉 100리터를 의미한다. 지연은 수도관 자체의 길이를 의미한다. 하나의 트랜잭션을 처리하고 끝날 때 까지 소요된 시간. 종단시간이라고도 한다. 

- 용량

시스템이 보유한 작업 병렬성의 총량으로 동시 처리 가능한 작업 단위 개수를 의미한다.

- 사용률

시스템 리소스를 얼마나 효율적으로 활용하는지를 의미한다.

- 효율

처리율을 리소스 사용률로 나눈 값

- 확장성

리소스를 어느정도 까지 늘리면 거의 선형적으로 확장되지만 부하가 높아지면 완벽한 확장을 저해하는 한계점에 봉착한다.

- 저하

부하를 받으면 지연 또는 처리율 측정값에 변화가 생기는데 이것을 저하라한다.

# 2장 JVM 이야기

처음부터 자바는 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계되었다.

→ 그래도 어느정도 이해가 필요함.

## 인터프리팅과 클래스 로딩

VM 스펙에 따르면 JVM은 스택 기반의 해석머신이다. 물리적 CPU 하드웨어인 레지스터는 없지만 일부 결과를 실행스택에 보관하며 이 스택의 맨 위에 쌓인 값들을 가져와서 계산한다.

JVM 인터프리터 기본 로직은 스택을 이용해 중간값들을 담아두고 opcode를 하나씩 순서대로 처리하는 while 루프 안의 switch문이다.

### 자바 클래스 로딩 메커니즘

부트 스트랩 클래스가 자바 런타임 코어 클래스를 로드한다(자바 8이전까지 rt.jar에서 가져왔지만 9 이후부터는 런타임이 모듈화되고 클래스로딩 개념자체가 달라졌다) 부트 스트랩 클래스의 주임무는 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 필수클래스 (Object, Class, ClassLoader 같은) 만 로드 한다→ 확장 클래스 로더가 생긴다 → 애플리케이션 클래스로더가 생긴다. (자세한 내용은 생략)

## 바이트 코드 실행

javac(자바컴파일러)을 이용해 컴파일을 하는데, 자바 소스를 바이트코드로 가득찬 .class 파일로 변환하는 일을 한다. 참고로 javac로 컴파일하는동안 최적화는 거의 하지 않기 때문에 javap같은 표준 역어셈블리 툴로 열어 보면 자바 코드도 알아볼 수 있다)

바이트코드는 특정 컴퓨터 아키텍쳐에 특정하지 않은 중간 표현형 (Intermediate Representation) 이다. 컴퓨터 아키텍쳐의 지배를 받지 않으므로 이식성이 좋아 개발을 마친 소프트웨어는 JVM 지원 플랫폼 어디서건 실행할 수 있다.

JVM은 클래스를 로드할 때 올바른 형식을 준수하고 있는지 빠짐없이 검사한다. 

모든 클래스 파일은 0xCAFEBABE 라는 매직넘버(클래스 파일임을 나타내는 4바이트 16진수)로 시작한다. 

## 핫스팟

99년도에 썬 사는 성능 관점에서 자바에 가장 큰 변화를 가져오는 핫스팟 가상머신을 선보였다. C/C++에 필적할 만한 성능을 자랑하며 진화를 하였다. 

자바 프로그램은 바이트코드 인터프리터가 가상화환 스택머신에서 명령어를 실행하며 시작된다. CPU를 추상화한 구조라서 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있다. 하지만 프로그램이 최대의 성능을 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다. 

이를 위해 핫스팟은 프로그램 단위를 (메서드와 루프) 인터프리티드 바이트코드에서 네이티브 코드로 컴파일한다. 그래서 JIT (Just In Time) 컴파일이라고 한다.

핫스팟은 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 자주 실행되는 코드를 발견해 JIT 컴파일을 수행한다. 이렇게 분석하는 동안 추적정보가 취합되면서 더 정교하게 최적화를 할 수 있다.

# 4장 성능 테스트 패턴 및 안티패턴

## 테스트 환경 구축

테스트 환경은 가급적 모든 면에서 운영 환경과 똑같이 복제해야 한다. 애플리케이션 서버 뿐만 아니라 (cpu수, OS, 자바 런타임 버전 까지) 웹 서버, db, 로드밸런서, 방화벽 등.

운영환경과 많이 차이나는 성능 테스트는 실제 환경에서 어떤 일들이 일어나날지 예측하기 어렵고 쓸모 있는 겨로가를 얻지 못할 가능성이 크다. 

## 성능 안티패턴

안티패턴은 사람들이 수많은 프로젝트를 수행하면서 밝혀낸, 소프트웨어 프로젝트 또는 팀의 좋지 않은 패턴이다.

### 지루함

개발자의 지루함은 프로젝트에 여러 가지로 해악을 끼칠 수 있는데 Collections.sort()를 쓰지않고 직접 정렬알고리즘을 구현하는 게 그 예이다. 

### 또래압박

팀원들이 기술을 결정할 때 관심사를 분명히 밝히지 않고, 서로 충분한 논의 없이 진행했을 때 쓴 결과가 나오는 경우. 섣불리 중요한 결정을 내리는것도 또래압박.

### 이해 부족

새로 나온 멋진 기술을 그대로 맹신하는 행위.

예를들어 하이버네이트의 경우 수박 겉핥기 식으로 이해하고 적용하는 경우. 

### 안티패턴 카탈로그

- 새 컴포넌트는 전후로 충분한 로그를 남긴다.
- 새로 적용하거나 바뀌는 매개변수를 UAT에서 시험해본다.
- 평소 의심했던 범인 (하이버네이트)를 수사 과정의 유일한 용의자로 지목하는 행위를 지양한다.
- 운영환경과 동일한 UAT 환경을 구입한다.
